{"version":3,"sources":["webpack:///inscript.js","webpack:///webpack/bootstrap a3e24e285c8487984fa2","webpack:///./src/inscript.js","webpack:///./src/object-assign.js","webpack:///./~/promise-polyfill/promise.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./~/setasap/setAsap.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_promisePolyfill","_promisePolyfill2","_setasap","_setasap2","window","document","updateDocScripts","scripts","docScripts","aps","filter","script","Boolean","src","isScriptLoaded","isShallow","cleanPath","replace","lastIndexOf","length","loadScript","validate","config","buffer","Array","isArray","inscript","accept","reject","shouldValidate","newScript","scriptTemplate","cloneNode","preventDuplicates","shallowScan","onload","async","appendChild","_setImmediateFn","defaults","useRaf","appendToHead","createElement","prototype","slice","options","Error","head","body","Object","assign","chain","createDocumentFragment","promiseChain","map","all","then","target","undefined","TypeError","output","index","arguments","source","nextKey","hasOwnProperty","setImmediate","root","noop","bind","fn","thisArg","apply","Promise","this","_state","_handled","_value","_deferreds","doResolve","handle","self","deferred","push","asap","cb","onFulfilled","onRejected","resolve","promise","ret","e","newValue","finale","setTimeout","onUnhandledRejection","i","len","Handler","done","value","reason","ex","setTimeoutFunc","err","console","warn","toString","prom","args","res","val","remaining","constructor","race","values","_setUnhandledRejectionFn","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","Function","immediateIds","nextImmediateId","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","run","Item","fun","array","process","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_RESULT__","global","thisVar","main","hasSetImmediate","hasNextTick","setAsap","getAsap","callback","callbacks","executeCallbacks","cbList","tryError","hiddenDiv","scriptEl","timeoutFn","MutationObserver","observe","attributes","setAttribute","postMessage","importScripts","addEventListener","MESSAGE_PREFIX","Math","random","onGlobalMessage","event","data","onreadystatechange","parentNode","removeChild"],"mappings":"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","file":"inscript.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t__webpack_require__(1);\n\t\n\tvar _promisePolyfill = __webpack_require__(2);\n\t\n\tvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\t\n\tvar _setasap = __webpack_require__(5);\n\t\n\tvar _setasap2 = _interopRequireDefault(_setasap);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t(function (window, document) {\n\t\n\t    _promisePolyfill2.default._setImmediateFn(_setasap2.default);\n\t\n\t    var defaults = {\n\t        async: true,\n\t        useRaf: true,\n\t        preventDuplicates: true,\n\t        shallowScan: true,\n\t        appendToHead: false\n\t    };\n\t\n\t    var docScripts = void 0;\n\t    var scriptTemplate = document.createElement(\"script\");\n\t    var aps = Array.prototype.slice;\n\t    /**\n\t     * @method\n\t     * @param {String|Array} scripts\n\t     * @param {Function} [validate] Function which determines validitiy of loaded script(s)\n\t     * @param {Object} [options]\n\t     */\n\t    window.inscript = window.inscript || function inscript(scripts, validate, options) {\n\t        if (!scripts) {\n\t            new Error(\"Scripts are not provided\");\n\t        }\n\t\n\t        updateDocScripts();\n\t\n\t        var head = document.head;\n\t        var body = document.body || head;\n\t        var config = Object.assign({}, defaults, options);\n\t        var chain = Array.isArray(scripts) ? scripts : [scripts];\n\t        var buffer = document.createDocumentFragment();\n\t        var promiseChain = chain.map(function (script) {\n\t            return loadScript(script, validate, config, buffer);\n\t        });\n\t\n\t        if (config.appendToHead) {\n\t            head.appendChild(buffer);\n\t        } else {\n\t            body.appendChild(buffer);\n\t        }\n\t\n\t        return _promisePolyfill2.default.all(promiseChain).then(updateDocScripts);\n\t    };\n\t\n\t    function updateDocScripts(scripts) {\n\t        docScripts = aps.call(document.scripts).filter(function (script) {\n\t            return Boolean(script.src);\n\t        });\n\t        return scripts;\n\t    }\n\t    /**\n\t     * Checks if script is already loaded in the document\n\t     * @private\n\t     * @param {String} src\n\t     * @param {Boolean} isShallow\n\t     */\n\t    function isScriptLoaded(src, isShallow) {\n\t        var cleanPath = src.replace(/\\.+/, \"\");\n\t        return Boolean(docScripts.filter(function (script) {\n\t            return isShallow ? script.src.lastIndexOf(cleanPath) >= 0 : script.src === src;\n\t        }).length);\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     * @param {String|Array} src\n\t     * @param {Object} config\n\t     * @param {DocumentFragment} buffer\n\t     * @returns {Promise}\n\t     */\n\t    function loadScript(src, validate, config, buffer) {\n\t        if (Array.isArray(src)) {\n\t            return window.inscript(src, validate, config);\n\t        }\n\t\n\t        return new _promisePolyfill2.default(function (accept, reject) {\n\t            var shouldValidate = typeof validate === \"function\";\n\t            var newScript = scriptTemplate.cloneNode(false);\n\t\n\t            if (config.preventDuplicates && isScriptLoaded(src, config.shallowScan)) {\n\t                accept(src);\n\t                return;\n\t            }\n\t\n\t            newScript.onload = function () {\n\t                if (shouldValidate && !validate(src)) {\n\t                    reject(\"Unable to validate script \" + src);\n\t                }\n\t\n\t                accept(src);\n\t                newScript.onload = null;\n\t            };\n\t\n\t            newScript.src = src;\n\t            newScript.async = config.async;\n\t\n\t            buffer.appendChild(newScript);\n\t        });\n\t    }\n\t})(window, document);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tif (typeof Object.assign != \"function\") {\n\t    (function () {\n\t        Object.assign = function (target) {\n\t            \"use strict\";\n\t\n\t            if (target === undefined || target === null) {\n\t                throw new TypeError(\"Cannot convert undefined or null to object\");\n\t            }\n\t\n\t            var output = Object(target);\n\t            for (var index = 1; index < arguments.length; index++) {\n\t                var source = arguments[index];\n\t                if (source !== undefined && source !== null) {\n\t                    for (var nextKey in source) {\n\t                        if (source.hasOwnProperty(nextKey)) {\n\t                            output[nextKey] = source[nextKey];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return output;\n\t        };\n\t    })();\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {\n\t\n\t  // Store setTimeout reference so promise-polyfill will be unaffected by\n\t  // other code modifying setTimeout (like sinon.useFakeTimers())\n\t  var setTimeoutFunc = setTimeout;\n\t\n\t  function noop() {\n\t  }\n\t\n\t  // Use polyfill for setImmediate for performance gains\n\t  var asap = (typeof setImmediate === 'function' && setImmediate) ||\n\t    function (fn) {\n\t      setTimeoutFunc(fn, 1);\n\t    };\n\t\n\t  var onUnhandledRejection = function onUnhandledRejection(err) {\n\t    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n\t  };\n\t\n\t  // Polyfill for Function.prototype.bind\n\t  function bind(fn, thisArg) {\n\t    return function () {\n\t      fn.apply(thisArg, arguments);\n\t    };\n\t  }\n\t\n\t  var isArray = Array.isArray || function (value) {\n\t    return Object.prototype.toString.call(value) === '[object Array]';\n\t  };\n\t\n\t  function Promise(fn) {\n\t    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n\t    if (typeof fn !== 'function') throw new TypeError('not a function');\n\t    this._state = 0;\n\t    this._handled = false;\n\t    this._value = undefined;\n\t    this._deferreds = [];\n\t\n\t    doResolve(fn, this);\n\t  }\n\t\n\t  function handle(self, deferred) {\n\t    while (self._state === 3) {\n\t      self = self._value;\n\t    }\n\t    if (self._state === 0) {\n\t      self._deferreds.push(deferred);\n\t      return;\n\t    }\n\t    self._handled = true;\n\t    asap(function () {\n\t      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t      if (cb === null) {\n\t        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n\t        return;\n\t      }\n\t      var ret;\n\t      try {\n\t        ret = cb(self._value);\n\t      } catch (e) {\n\t        reject(deferred.promise, e);\n\t        return;\n\t      }\n\t      resolve(deferred.promise, ret);\n\t    });\n\t  }\n\t\n\t  function resolve(self, newValue) {\n\t    try {\n\t      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\t      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n\t        var then = newValue.then;\n\t        if (newValue instanceof Promise) {\n\t          self._state = 3;\n\t          self._value = newValue;\n\t          finale(self);\n\t          return;\n\t        } else if (typeof then === 'function') {\n\t          doResolve(bind(then, newValue), self);\n\t          return;\n\t        }\n\t      }\n\t      self._state = 1;\n\t      self._value = newValue;\n\t      finale(self);\n\t    } catch (e) {\n\t      reject(self, e);\n\t    }\n\t  }\n\t\n\t  function reject(self, newValue) {\n\t    self._state = 2;\n\t    self._value = newValue;\n\t    finale(self);\n\t  }\n\t\n\t  function finale(self) {\n\t    if (self._state === 2 && self._deferreds.length === 0) {\n\t      setTimeout(function() {\n\t        if (!self._handled) {\n\t          onUnhandledRejection(self._value);\n\t        }\n\t      }, 1);\n\t    }\n\t    \n\t    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n\t      handle(self, self._deferreds[i]);\n\t    }\n\t    self._deferreds = null;\n\t  }\n\t\n\t  function Handler(onFulfilled, onRejected, promise) {\n\t    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t    this.promise = promise;\n\t  }\n\t\n\t  /**\n\t   * Take a potentially misbehaving resolver function and make sure\n\t   * onFulfilled and onRejected are only called once.\n\t   *\n\t   * Makes no guarantees about asynchrony.\n\t   */\n\t  function doResolve(fn, self) {\n\t    var done = false;\n\t    try {\n\t      fn(function (value) {\n\t        if (done) return;\n\t        done = true;\n\t        resolve(self, value);\n\t      }, function (reason) {\n\t        if (done) return;\n\t        done = true;\n\t        reject(self, reason);\n\t      });\n\t    } catch (ex) {\n\t      if (done) return;\n\t      done = true;\n\t      reject(self, ex);\n\t    }\n\t  }\n\t\n\t  Promise.prototype['catch'] = function (onRejected) {\n\t    return this.then(null, onRejected);\n\t  };\n\t\n\t  Promise.prototype.then = function (onFulfilled, onRejected) {\n\t    var prom = new Promise(noop);\n\t    handle(this, new Handler(onFulfilled, onRejected, prom));\n\t    return prom;\n\t  };\n\t\n\t  Promise.all = function () {\n\t    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\t\n\t    return new Promise(function (resolve, reject) {\n\t      if (args.length === 0) return resolve([]);\n\t      var remaining = args.length;\n\t\n\t      function res(i, val) {\n\t        try {\n\t          if (val && (typeof val === 'object' || typeof val === 'function')) {\n\t            var then = val.then;\n\t            if (typeof then === 'function') {\n\t              then.call(val, function (val) {\n\t                res(i, val);\n\t              }, reject);\n\t              return;\n\t            }\n\t          }\n\t          args[i] = val;\n\t          if (--remaining === 0) {\n\t            resolve(args);\n\t          }\n\t        } catch (ex) {\n\t          reject(ex);\n\t        }\n\t      }\n\t\n\t      for (var i = 0; i < args.length; i++) {\n\t        res(i, args[i]);\n\t      }\n\t    });\n\t  };\n\t\n\t  Promise.resolve = function (value) {\n\t    if (value && typeof value === 'object' && value.constructor === Promise) {\n\t      return value;\n\t    }\n\t\n\t    return new Promise(function (resolve) {\n\t      resolve(value);\n\t    });\n\t  };\n\t\n\t  Promise.reject = function (value) {\n\t    return new Promise(function (resolve, reject) {\n\t      reject(value);\n\t    });\n\t  };\n\t\n\t  Promise.race = function (values) {\n\t    return new Promise(function (resolve, reject) {\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        values[i].then(resolve, reject);\n\t      }\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Set the immediate function to execute callbacks\n\t   * @param fn {function} Function to execute\n\t   * @private\n\t   */\n\t  Promise._setImmediateFn = function _setImmediateFn(fn) {\n\t    asap = fn;\n\t  };\n\t  \n\t  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n\t    onUnhandledRejection = fn;\n\t  };\n\t\n\t  if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = Promise;\n\t  } else if (!root.Promise) {\n\t    root.Promise = Promise;\n\t  }\n\t\n\t})(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {(function (thisVar, undefined) {\n\t\t'use strict';\n\t\tvar main = (typeof window === 'object' && window) || (typeof global === 'object' && global) ||\n\t\t\ttypeof self === 'object' && self || thisVar;\n\t\n\t\tvar hasSetImmediate = typeof setImmediate === 'function';\n\t\tvar hasNextTick = typeof process === 'object' && !!process && typeof process.nextTick === 'function';\n\t\n\t\tvar setAsap = (function () {\n\t\t\tvar callbacks = [], hiddenDiv, scriptEl, timeoutFn;\n\t\n\t\t\t// Modern browsers, fastest async\n\t\t\tif (main.MutationObserver) {\n\t\t\t\thiddenDiv = document.createElement(\"div\");\n\t\t\t\t(new MutationObserver(executeCallbacks)).observe(hiddenDiv, { attributes: true });\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\thiddenDiv.setAttribute('yes', 'no');\n\t\t\t\t});\n\t\n\t\t\t// Browsers that support postMessage\n\t\t\t} else if (!hasSetImmediate && main.postMessage && !main.importScripts && main.addEventListener) {\n\t\t\t\tvar MESSAGE_PREFIX = \"com.setImmediate\" + Math.random(), hasPostMessage = false;\n\t\n\t\t\t\tvar onGlobalMessage = function (event) {\n\t\t\t\t\tif (event.source === main && event.data === MESSAGE_PREFIX) {\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tmain.addEventListener(\"message\", onGlobalMessage, false);\n\t\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\tmain.postMessage(MESSAGE_PREFIX, \"*\");\n\t\t\t\t});\n\t\n\t\t\t\t// IE browsers without postMessage\n\t\t\t} else if (!hasSetImmediate && main.document && 'onreadystatechange' in document.createElement('script')) {\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\tscriptEl = document.createElement(\"script\");\n\t\t\t\t\tscriptEl.onreadystatechange = function () {\n\t\t\t\t\t\tscriptEl.onreadystatechange = null;\n\t\t\t\t\t\tscriptEl.parentNode.removeChild(scriptEl);\n\t\t\t\t\t\tscriptEl = null;\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t};\n\t\t\t\t\tdocument.body.appendChild(scriptEl);\n\t\t\t\t});\n\t\n\t\t\t// All other browsers and node\n\t\t\t} else {\n\t\t\t\ttimeoutFn = (hasSetImmediate && setImmediate) || (hasNextTick && process.nextTick) || setTimeout;\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\ttimeoutFn(function () {\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tfunction getAsap(fn) {\n\t\t\t\treturn function (callback) {\n\t\t\t\t\tif (!callbacks.length) {\n\t\t\t\t\t\tfn();\n\t\t\t\t\t}\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction executeCallbacks() {\n\t\t\t\tvar cbList = callbacks;\n\t\t\t\tcallbacks = [];\n\t\t\t\tfor (var i = 0, len = cbList.length; i < len; i++) {\n\t\t\t\t\ttryError(cbList[i]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction tryError(fn) {\n\t\t\t\ttry {\n\t\t\t\t\tfn();\n\t\t\t\t} catch(e) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t})();\n\t\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\tmodule.exports = setAsap;\n\t\t} else if (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\t\treturn setAsap;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else {\n\t\t\tmain.setAsap = setAsap;\n\t\t}\n\t})(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3).setImmediate, __webpack_require__(4)))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** inscript.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a3e24e285c8487984fa2\n **/","import \"./object-assign\";\nimport Promise from \"promise-polyfill\";\nimport setAsap from \"setasap\";\n\n(function(window, document) {\n    \n    Promise._setImmediateFn(setAsap);\n    \n    const defaults = {\n        async: true,\n        useRaf: true,\n        preventDuplicates: true,\n        shallowScan: true,\n        appendToHead: false\n    };\n\n    let docScripts;\n    const scriptTemplate = document.createElement(\"script\");\n    const aps = Array.prototype.slice;\n    /**\n     * @method\n     * @param {String|Array} scripts\n     * @param {Function} [validate] Function which determines validitiy of loaded script(s)\n     * @param {Object} [options]\n     */\n    window.inscript = window.inscript || function inscript(scripts, validate, options) {\n        if (!scripts) {\n            new Error(\"Scripts are not provided\");\n        }\n\n        updateDocScripts();\n\n        const head = document.head;\n        const body = document.body || head;\n        const config = Object.assign({}, defaults, options);\n        const chain = Array.isArray(scripts) ? scripts : [scripts];\n        const buffer = document.createDocumentFragment();\n        const promiseChain = chain.map((script) => loadScript(script, validate, config, buffer));\n\n        if (config.appendToHead) {\n            head.appendChild(buffer);\n        } else {\n            body.appendChild(buffer);\n        }\n\n        return Promise.all(promiseChain)\n            .then(updateDocScripts);\n    };\n\n    function updateDocScripts(scripts) {\n        docScripts = aps.call(document.scripts).filter((script) => Boolean(script.src));\n        return scripts;\n    }\n    /**\n     * Checks if script is already loaded in the document\n     * @private\n     * @param {String} src\n     * @param {Boolean} isShallow\n     */\n    function isScriptLoaded(src, isShallow) {\n        const cleanPath = src.replace(/\\.+/, \"\");\n        return Boolean(\n            docScripts.filter((script) =>\n                isShallow ? (script.src.lastIndexOf(cleanPath) >= 0) : (script.src === src)\n            ).length\n        );\n    }\n\n    /**\n     * @private\n     * @param {String|Array} src\n     * @param {Object} config\n     * @param {DocumentFragment} buffer\n     * @returns {Promise}\n     */\n    function loadScript(src, validate, config, buffer) {\n        if (Array.isArray(src)) {\n            return window.inscript(src, validate, config);\n        }\n\n        return new Promise((accept, reject) => {\n            const shouldValidate = typeof (validate) === \"function\";\n            const newScript = scriptTemplate.cloneNode(false);\n\n            if (config.preventDuplicates && isScriptLoaded(src, config.shallowScan)) {\n                accept(src);\n                return;\n            }\n\n            newScript.onload = function() {\n                if (shouldValidate && !validate(src)) {\n                    reject(`Unable to validate script ${src}`);\n                }\n\n                accept(src);\n                newScript.onload = null;\n            };\n\n            newScript.src = src;\n            newScript.async = config.async;\n\n            buffer.appendChild(newScript);\n        });\n    }\n\n})(window, document);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/inscript.js\n **/","if (typeof Object.assign != \"function\") {\n    (function() {\n        Object.assign = function(target) {\n            \"use strict\";\n            if (target === undefined || target === null) {\n                throw new TypeError(\"Cannot convert undefined or null to object\");\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    })();\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object-assign.js\n **/","(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {\n  }\n\n  // Use polyfill for setImmediate for performance gains\n  var asap = (typeof setImmediate === 'function' && setImmediate) ||\n    function (fn) {\n      setTimeoutFunc(fn, 1);\n    };\n\n  var onUnhandledRejection = function onUnhandledRejection(err) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  };\n\n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  var isArray = Array.isArray || function (value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    asap(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      setTimeout(function() {\n        if (!self._handled) {\n          onUnhandledRejection(self._value);\n        }\n      }, 1);\n    }\n    \n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new Promise(noop);\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function () {\n    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @private\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    asap = fn;\n  };\n  \n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    onUnhandledRejection = fn;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/promise-polyfill/promise.js\n ** module id = 2\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 3\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 4\n ** module chunks = 0\n **/","(function (thisVar, undefined) {\n\t'use strict';\n\tvar main = (typeof window === 'object' && window) || (typeof global === 'object' && global) ||\n\t\ttypeof self === 'object' && self || thisVar;\n\n\tvar hasSetImmediate = typeof setImmediate === 'function';\n\tvar hasNextTick = typeof process === 'object' && !!process && typeof process.nextTick === 'function';\n\n\tvar setAsap = (function () {\n\t\tvar callbacks = [], hiddenDiv, scriptEl, timeoutFn;\n\n\t\t// Modern browsers, fastest async\n\t\tif (main.MutationObserver) {\n\t\t\thiddenDiv = document.createElement(\"div\");\n\t\t\t(new MutationObserver(executeCallbacks)).observe(hiddenDiv, { attributes: true });\n\t\t\treturn getAsap(function () {\n\t\t\t\thiddenDiv.setAttribute('yes', 'no');\n\t\t\t});\n\n\t\t// Browsers that support postMessage\n\t\t} else if (!hasSetImmediate && main.postMessage && !main.importScripts && main.addEventListener) {\n\t\t\tvar MESSAGE_PREFIX = \"com.setImmediate\" + Math.random(), hasPostMessage = false;\n\n\t\t\tvar onGlobalMessage = function (event) {\n\t\t\t\tif (event.source === main && event.data === MESSAGE_PREFIX) {\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmain.addEventListener(\"message\", onGlobalMessage, false);\n\n\t\t\treturn getAsap(function () {\n\t\t\t\tmain.postMessage(MESSAGE_PREFIX, \"*\");\n\t\t\t});\n\n\t\t\t// IE browsers without postMessage\n\t\t} else if (!hasSetImmediate && main.document && 'onreadystatechange' in document.createElement('script')) {\n\t\t\treturn getAsap(function () {\n\t\t\t\tscriptEl = document.createElement(\"script\");\n\t\t\t\tscriptEl.onreadystatechange = function () {\n\t\t\t\t\tscriptEl.onreadystatechange = null;\n\t\t\t\t\tscriptEl.parentNode.removeChild(scriptEl);\n\t\t\t\t\tscriptEl = null;\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t};\n\t\t\t\tdocument.body.appendChild(scriptEl);\n\t\t\t});\n\n\t\t// All other browsers and node\n\t\t} else {\n\t\t\ttimeoutFn = (hasSetImmediate && setImmediate) || (hasNextTick && process.nextTick) || setTimeout;\n\t\t\treturn getAsap(function () {\n\t\t\t\ttimeoutFn(function () {\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t}, 0);\n\t\t\t});\n\t\t}\n\n\t\tfunction getAsap(fn) {\n\t\t\treturn function (callback) {\n\t\t\t\tif (!callbacks.length) {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t\tcallbacks.push(callback);\n\t\t\t}\n\t\t}\n\n\t\tfunction executeCallbacks() {\n\t\t\tvar cbList = callbacks;\n\t\t\tcallbacks = [];\n\t\t\tfor (var i = 0, len = cbList.length; i < len; i++) {\n\t\t\t\ttryError(cbList[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction tryError(fn) {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch(e) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t})();\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = setAsap;\n\t} else if (typeof require !== 'undefined' && require.amd) {\n\t\tdefine(function () {\n\t\t\treturn setAsap;\n\t\t});\n\t} else {\n\t\tmain.setAsap = setAsap;\n\t}\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/setasap/setAsap.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}