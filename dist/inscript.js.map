{"version":3,"sources":["webpack:///inscript.js","webpack:///webpack/bootstrap 5daf5ae8e4ce850797ab","webpack:///./src/inscript.js","webpack:///./src/object-assign.js","webpack:///./~/promise-polyfill/promise.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./~/setasap/setAsap.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","_promisePolyfill","_promisePolyfill2","_setasap","_setasap2","window","document","updateDocScripts","scripts","docScripts","aps","filter","script","Boolean","src","isScriptLoaded","isShallow","cleanPath","replace","lastIndexOf","length","loadScript","config","buffer","Array","isArray","inscript","accept","newScript","scriptTemplate","cloneNode","preventDuplicates","shallowScan","onload","onerror","async","appendChild","_setImmediateFn","defaults","appendToHead","createElement","prototype","slice","options","Error","head","body","assign","chain","createDocumentFragment","promiseChain","map","all","then","reduce","result","target","undefined","TypeError","output","index","arguments","source","nextKey","hasOwnProperty","setImmediate","root","noop","bind","fn","thisArg","apply","Promise","this","_state","_handled","_value","_deferreds","doResolve","handle","self","deferred","push","asap","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","finale","setTimeout","onUnhandledRejection","i","len","Handler","done","reason","ex","setTimeoutFunc","err","console","warn","toString","prom","args","res","val","remaining","constructor","race","values","_setUnhandledRejectionFn","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","Function","immediateIds","nextImmediateId","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","run","Item","fun","array","process","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_RESULT__","global","thisVar","main","hasSetImmediate","hasNextTick","setAsap","getAsap","callback","callbacks","executeCallbacks","cbList","tryError","hiddenDiv","scriptEl","timeoutFn","MutationObserver","observe","attributes","setAttribute","postMessage","importScripts","addEventListener","MESSAGE_PREFIX","Math","random","onGlobalMessage","event","data","onreadystatechange","parentNode","removeChild"],"mappings":"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","file":"inscript.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t__webpack_require__(1);\n\t\n\tvar _promisePolyfill = __webpack_require__(2);\n\t\n\tvar _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);\n\t\n\tvar _setasap = __webpack_require__(5);\n\t\n\tvar _setasap2 = _interopRequireDefault(_setasap);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t(function (window, document) {\n\t\n\t    _promisePolyfill2.default._setImmediateFn(_setasap2.default);\n\t\n\t    /**\n\t     * @typedef {Object} InscriptOptions\n\t     * @param {Boolean} async\n\t     * @param {Boolean} preventDuplicates\n\t     * @param {Boolean} shallowScan\n\t     * @param {Boolean} appendToHead\n\t     */\n\t    var defaults = {\n\t        async: true,\n\t        preventDuplicates: true,\n\t        shallowScan: true,\n\t        appendToHead: false\n\t    };\n\t\n\t    var docScripts = void 0;\n\t    var scriptTemplate = document.createElement(\"script\");\n\t    var aps = Array.prototype.slice;\n\t    /**\n\t     * @method\n\t     * @param {String|Array} scripts\n\t     * @param {InscriptOptions} [options]\n\t     */\n\t    window.inscript = window.inscript || function inscript(scripts, options) {\n\t        if (!scripts) {\n\t            new Error(\"Scripts are not provided\");\n\t        }\n\t\n\t        updateDocScripts();\n\t\n\t        var head = document.head;\n\t        var body = document.body || head;\n\t        var config = Object.assign({}, defaults, options);\n\t        var chain = Array.isArray(scripts) ? scripts : [scripts];\n\t        var buffer = document.createDocumentFragment();\n\t        var promiseChain = chain.map(function (script) {\n\t            return loadScript(script, config, buffer);\n\t        });\n\t\n\t        if (config.appendToHead) {\n\t            head.appendChild(buffer);\n\t        } else {\n\t            body.appendChild(buffer);\n\t        }\n\t\n\t        return _promisePolyfill2.default.all(promiseChain).then(function (scripts) {\n\t            return scripts.reduce(function (result, script) {\n\t                return Object.assign(result, script.src ? _defineProperty({}, script.src, script.loaded) : script);\n\t            }, {});\n\t        }).then(updateDocScripts);\n\t    };\n\t\n\t    function updateDocScripts(scripts) {\n\t        docScripts = aps.call(document.scripts).filter(function (script) {\n\t            return Boolean(script.src);\n\t        });\n\t        return scripts;\n\t    }\n\t    /**\n\t     * Checks if script is already loaded in the document\n\t     * @private\n\t     * @param {String} src\n\t     * @param {Boolean} isShallow\n\t     */\n\t    function isScriptLoaded(src, isShallow) {\n\t        var cleanPath = src.replace(/\\.+/, \"\");\n\t        return Boolean(docScripts.filter(function (script) {\n\t            return isShallow ? script.src.lastIndexOf(cleanPath) >= 0 : script.src === src;\n\t        }).length);\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     * @param {String|Array} src\n\t     * @param {Object} config\n\t     * @param {DocumentFragment} buffer\n\t     * @returns {Promise}\n\t     */\n\t    function loadScript(src, config, buffer) {\n\t        if (Array.isArray(src)) {\n\t            return window.inscript(src, config);\n\t        }\n\t\n\t        return new _promisePolyfill2.default(function (accept) {\n\t            var newScript = scriptTemplate.cloneNode(false);\n\t\n\t            if (config.preventDuplicates && isScriptLoaded(src, config.shallowScan)) {\n\t                accept({ src: src, loaded: true });\n\t                return;\n\t            }\n\t\n\t            newScript.onload = function () {\n\t                newScript.onload = null;\n\t                accept({ src: src, loaded: true });\n\t            };\n\t\n\t            newScript.onerror = function () {\n\t                newScript.onerror = null;\n\t                accept({ src: src, loaded: false });\n\t            };\n\t\n\t            newScript.src = src;\n\t            newScript.async = config.async;\n\t\n\t            buffer.appendChild(newScript);\n\t        });\n\t    }\n\t})(window, document);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tif (typeof Object.assign != \"function\") {\n\t    (function () {\n\t        Object.assign = function (target) {\n\t            \"use strict\";\n\t\n\t            if (target === undefined || target === null) {\n\t                throw new TypeError(\"Cannot convert undefined or null to object\");\n\t            }\n\t\n\t            var output = Object(target);\n\t            for (var index = 1; index < arguments.length; index++) {\n\t                var source = arguments[index];\n\t                if (source !== undefined && source !== null) {\n\t                    for (var nextKey in source) {\n\t                        if (source.hasOwnProperty(nextKey)) {\n\t                            output[nextKey] = source[nextKey];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return output;\n\t        };\n\t    })();\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {\n\t\n\t  // Store setTimeout reference so promise-polyfill will be unaffected by\n\t  // other code modifying setTimeout (like sinon.useFakeTimers())\n\t  var setTimeoutFunc = setTimeout;\n\t\n\t  function noop() {\n\t  }\n\t\n\t  // Use polyfill for setImmediate for performance gains\n\t  var asap = (typeof setImmediate === 'function' && setImmediate) ||\n\t    function (fn) {\n\t      setTimeoutFunc(fn, 1);\n\t    };\n\t\n\t  var onUnhandledRejection = function onUnhandledRejection(err) {\n\t    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n\t  };\n\t\n\t  // Polyfill for Function.prototype.bind\n\t  function bind(fn, thisArg) {\n\t    return function () {\n\t      fn.apply(thisArg, arguments);\n\t    };\n\t  }\n\t\n\t  var isArray = Array.isArray || function (value) {\n\t    return Object.prototype.toString.call(value) === '[object Array]';\n\t  };\n\t\n\t  function Promise(fn) {\n\t    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n\t    if (typeof fn !== 'function') throw new TypeError('not a function');\n\t    this._state = 0;\n\t    this._handled = false;\n\t    this._value = undefined;\n\t    this._deferreds = [];\n\t\n\t    doResolve(fn, this);\n\t  }\n\t\n\t  function handle(self, deferred) {\n\t    while (self._state === 3) {\n\t      self = self._value;\n\t    }\n\t    if (self._state === 0) {\n\t      self._deferreds.push(deferred);\n\t      return;\n\t    }\n\t    self._handled = true;\n\t    asap(function () {\n\t      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t      if (cb === null) {\n\t        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n\t        return;\n\t      }\n\t      var ret;\n\t      try {\n\t        ret = cb(self._value);\n\t      } catch (e) {\n\t        reject(deferred.promise, e);\n\t        return;\n\t      }\n\t      resolve(deferred.promise, ret);\n\t    });\n\t  }\n\t\n\t  function resolve(self, newValue) {\n\t    try {\n\t      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n\t      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n\t        var then = newValue.then;\n\t        if (newValue instanceof Promise) {\n\t          self._state = 3;\n\t          self._value = newValue;\n\t          finale(self);\n\t          return;\n\t        } else if (typeof then === 'function') {\n\t          doResolve(bind(then, newValue), self);\n\t          return;\n\t        }\n\t      }\n\t      self._state = 1;\n\t      self._value = newValue;\n\t      finale(self);\n\t    } catch (e) {\n\t      reject(self, e);\n\t    }\n\t  }\n\t\n\t  function reject(self, newValue) {\n\t    self._state = 2;\n\t    self._value = newValue;\n\t    finale(self);\n\t  }\n\t\n\t  function finale(self) {\n\t    if (self._state === 2 && self._deferreds.length === 0) {\n\t      setTimeout(function() {\n\t        if (!self._handled) {\n\t          onUnhandledRejection(self._value);\n\t        }\n\t      }, 1);\n\t    }\n\t    \n\t    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n\t      handle(self, self._deferreds[i]);\n\t    }\n\t    self._deferreds = null;\n\t  }\n\t\n\t  function Handler(onFulfilled, onRejected, promise) {\n\t    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t    this.promise = promise;\n\t  }\n\t\n\t  /**\n\t   * Take a potentially misbehaving resolver function and make sure\n\t   * onFulfilled and onRejected are only called once.\n\t   *\n\t   * Makes no guarantees about asynchrony.\n\t   */\n\t  function doResolve(fn, self) {\n\t    var done = false;\n\t    try {\n\t      fn(function (value) {\n\t        if (done) return;\n\t        done = true;\n\t        resolve(self, value);\n\t      }, function (reason) {\n\t        if (done) return;\n\t        done = true;\n\t        reject(self, reason);\n\t      });\n\t    } catch (ex) {\n\t      if (done) return;\n\t      done = true;\n\t      reject(self, ex);\n\t    }\n\t  }\n\t\n\t  Promise.prototype['catch'] = function (onRejected) {\n\t    return this.then(null, onRejected);\n\t  };\n\t\n\t  Promise.prototype.then = function (onFulfilled, onRejected) {\n\t    var prom = new Promise(noop);\n\t    handle(this, new Handler(onFulfilled, onRejected, prom));\n\t    return prom;\n\t  };\n\t\n\t  Promise.all = function () {\n\t    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\t\n\t    return new Promise(function (resolve, reject) {\n\t      if (args.length === 0) return resolve([]);\n\t      var remaining = args.length;\n\t\n\t      function res(i, val) {\n\t        try {\n\t          if (val && (typeof val === 'object' || typeof val === 'function')) {\n\t            var then = val.then;\n\t            if (typeof then === 'function') {\n\t              then.call(val, function (val) {\n\t                res(i, val);\n\t              }, reject);\n\t              return;\n\t            }\n\t          }\n\t          args[i] = val;\n\t          if (--remaining === 0) {\n\t            resolve(args);\n\t          }\n\t        } catch (ex) {\n\t          reject(ex);\n\t        }\n\t      }\n\t\n\t      for (var i = 0; i < args.length; i++) {\n\t        res(i, args[i]);\n\t      }\n\t    });\n\t  };\n\t\n\t  Promise.resolve = function (value) {\n\t    if (value && typeof value === 'object' && value.constructor === Promise) {\n\t      return value;\n\t    }\n\t\n\t    return new Promise(function (resolve) {\n\t      resolve(value);\n\t    });\n\t  };\n\t\n\t  Promise.reject = function (value) {\n\t    return new Promise(function (resolve, reject) {\n\t      reject(value);\n\t    });\n\t  };\n\t\n\t  Promise.race = function (values) {\n\t    return new Promise(function (resolve, reject) {\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        values[i].then(resolve, reject);\n\t      }\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Set the immediate function to execute callbacks\n\t   * @param fn {function} Function to execute\n\t   * @private\n\t   */\n\t  Promise._setImmediateFn = function _setImmediateFn(fn) {\n\t    asap = fn;\n\t  };\n\t  \n\t  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n\t    onUnhandledRejection = fn;\n\t  };\n\t\n\t  if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = Promise;\n\t  } else if (!root.Promise) {\n\t    root.Promise = Promise;\n\t  }\n\t\n\t})(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {(function (thisVar, undefined) {\n\t\t'use strict';\n\t\tvar main = (typeof window === 'object' && window) || (typeof global === 'object' && global) ||\n\t\t\ttypeof self === 'object' && self || thisVar;\n\t\n\t\tvar hasSetImmediate = typeof setImmediate === 'function';\n\t\tvar hasNextTick = typeof process === 'object' && !!process && typeof process.nextTick === 'function';\n\t\n\t\tvar setAsap = (function () {\n\t\t\tvar callbacks = [], hiddenDiv, scriptEl, timeoutFn;\n\t\n\t\t\t// Modern browsers, fastest async\n\t\t\tif (main.MutationObserver) {\n\t\t\t\thiddenDiv = document.createElement(\"div\");\n\t\t\t\t(new MutationObserver(executeCallbacks)).observe(hiddenDiv, { attributes: true });\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\thiddenDiv.setAttribute('yes', 'no');\n\t\t\t\t});\n\t\n\t\t\t// Browsers that support postMessage\n\t\t\t} else if (!hasSetImmediate && main.postMessage && !main.importScripts && main.addEventListener) {\n\t\t\t\tvar MESSAGE_PREFIX = \"com.setImmediate\" + Math.random(), hasPostMessage = false;\n\t\n\t\t\t\tvar onGlobalMessage = function (event) {\n\t\t\t\t\tif (event.source === main && event.data === MESSAGE_PREFIX) {\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tmain.addEventListener(\"message\", onGlobalMessage, false);\n\t\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\tmain.postMessage(MESSAGE_PREFIX, \"*\");\n\t\t\t\t});\n\t\n\t\t\t\t// IE browsers without postMessage\n\t\t\t} else if (!hasSetImmediate && main.document && 'onreadystatechange' in document.createElement('script')) {\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\tscriptEl = document.createElement(\"script\");\n\t\t\t\t\tscriptEl.onreadystatechange = function () {\n\t\t\t\t\t\tscriptEl.onreadystatechange = null;\n\t\t\t\t\t\tscriptEl.parentNode.removeChild(scriptEl);\n\t\t\t\t\t\tscriptEl = null;\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t};\n\t\t\t\t\tdocument.body.appendChild(scriptEl);\n\t\t\t\t});\n\t\n\t\t\t// All other browsers and node\n\t\t\t} else {\n\t\t\t\ttimeoutFn = (hasSetImmediate && setImmediate) || (hasNextTick && process.nextTick) || setTimeout;\n\t\t\t\treturn getAsap(function () {\n\t\t\t\t\ttimeoutFn(function () {\n\t\t\t\t\t\texecuteCallbacks();\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tfunction getAsap(fn) {\n\t\t\t\treturn function (callback) {\n\t\t\t\t\tif (!callbacks.length) {\n\t\t\t\t\t\tfn();\n\t\t\t\t\t}\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction executeCallbacks() {\n\t\t\t\tvar cbList = callbacks;\n\t\t\t\tcallbacks = [];\n\t\t\t\tfor (var i = 0, len = cbList.length; i < len; i++) {\n\t\t\t\t\ttryError(cbList[i]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction tryError(fn) {\n\t\t\t\ttry {\n\t\t\t\t\tfn();\n\t\t\t\t} catch(e) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t})();\n\t\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\tmodule.exports = setAsap;\n\t\t} else if (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\t\treturn setAsap;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t} else {\n\t\t\tmain.setAsap = setAsap;\n\t\t}\n\t})(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(3).setImmediate, __webpack_require__(4)))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** inscript.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5daf5ae8e4ce850797ab\n **/","import \"./object-assign\";\nimport Promise from \"promise-polyfill\";\nimport setAsap from \"setasap\";\n\n(function(window, document) {\n\n    Promise._setImmediateFn(setAsap);\n\n    /**\n     * @typedef {Object} InscriptOptions\n     * @param {Boolean} async\n     * @param {Boolean} preventDuplicates\n     * @param {Boolean} shallowScan\n     * @param {Boolean} appendToHead\n     */\n    const defaults = {\n        async: true,\n        preventDuplicates: true,\n        shallowScan: true,\n        appendToHead: false\n    };\n\n    let docScripts;\n    const scriptTemplate = document.createElement(\"script\");\n    const aps = Array.prototype.slice;\n    /**\n     * @method\n     * @param {String|Array} scripts\n     * @param {InscriptOptions} [options]\n     */\n    window.inscript = window.inscript || function inscript(scripts, options) {\n        if (!scripts) {\n            new Error(\"Scripts are not provided\");\n        }\n\n        updateDocScripts();\n\n        const head = document.head;\n        const body = document.body || head;\n        const config = Object.assign({}, defaults, options);\n        const chain = Array.isArray(scripts) ? scripts : [scripts];\n        const buffer = document.createDocumentFragment();\n        const promiseChain = chain.map((script) => loadScript(script, config, buffer));\n\n        if (config.appendToHead) {\n            head.appendChild(buffer);\n        } else {\n            body.appendChild(buffer);\n        }\n\n        return Promise.all(promiseChain)\n            .then((scripts) => scripts.reduce((result, script) => Object.assign(result, script.src ? { [script.src]: script.loaded } : script), {}))\n            .then(updateDocScripts);\n    };\n\n    function updateDocScripts(scripts) {\n        docScripts = aps.call(document.scripts).filter((script) => Boolean(script.src));\n        return scripts;\n    }\n    /**\n     * Checks if script is already loaded in the document\n     * @private\n     * @param {String} src\n     * @param {Boolean} isShallow\n     */\n    function isScriptLoaded(src, isShallow) {\n        const cleanPath = src.replace(/\\.+/, \"\");\n        return Boolean(\n            docScripts.filter((script) =>\n                isShallow ? (script.src.lastIndexOf(cleanPath) >= 0) : (script.src === src)\n            ).length\n        );\n    }\n\n    /**\n     * @private\n     * @param {String|Array} src\n     * @param {Object} config\n     * @param {DocumentFragment} buffer\n     * @returns {Promise}\n     */\n    function loadScript(src, config, buffer) {\n        if (Array.isArray(src)) {\n            return window.inscript(src, config);\n        }\n\n        return new Promise((accept) => {\n            const newScript = scriptTemplate.cloneNode(false);\n\n            if (config.preventDuplicates && isScriptLoaded(src, config.shallowScan)) {\n                accept({ src, loaded: true });\n                return;\n            }\n\n            newScript.onload = function() {\n                newScript.onload = null;\n                accept({ src, loaded: true });\n            };\n\n            newScript.onerror = function() {\n                newScript.onerror = null;\n                accept({ src, loaded: false });\n            };\n\n            newScript.src = src;\n            newScript.async = config.async;\n\n            buffer.appendChild(newScript);\n        });\n    }\n\n})(window, document);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/inscript.js\n **/","if (typeof Object.assign != \"function\") {\n    (function() {\n        Object.assign = function(target) {\n            \"use strict\";\n            if (target === undefined || target === null) {\n                throw new TypeError(\"Cannot convert undefined or null to object\");\n            }\n\n            var output = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n                var source = arguments[index];\n                if (source !== undefined && source !== null) {\n                    for (var nextKey in source) {\n                        if (source.hasOwnProperty(nextKey)) {\n                            output[nextKey] = source[nextKey];\n                        }\n                    }\n                }\n            }\n            return output;\n        };\n    })();\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/object-assign.js\n **/","(function (root) {\n\n  // Store setTimeout reference so promise-polyfill will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var setTimeoutFunc = setTimeout;\n\n  function noop() {\n  }\n\n  // Use polyfill for setImmediate for performance gains\n  var asap = (typeof setImmediate === 'function' && setImmediate) ||\n    function (fn) {\n      setTimeoutFunc(fn, 1);\n    };\n\n  var onUnhandledRejection = function onUnhandledRejection(err) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  };\n\n  // Polyfill for Function.prototype.bind\n  function bind(fn, thisArg) {\n    return function () {\n      fn.apply(thisArg, arguments);\n    };\n  }\n\n  var isArray = Array.isArray || function (value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  function Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    if (typeof fn !== 'function') throw new TypeError('not a function');\n    this._state = 0;\n    this._handled = false;\n    this._value = undefined;\n    this._deferreds = [];\n\n    doResolve(fn, this);\n  }\n\n  function handle(self, deferred) {\n    while (self._state === 3) {\n      self = self._value;\n    }\n    if (self._state === 0) {\n      self._deferreds.push(deferred);\n      return;\n    }\n    self._handled = true;\n    asap(function () {\n      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n      if (cb === null) {\n        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n        return;\n      }\n      var ret;\n      try {\n        ret = cb(self._value);\n      } catch (e) {\n        reject(deferred.promise, e);\n        return;\n      }\n      resolve(deferred.promise, ret);\n    });\n  }\n\n  function resolve(self, newValue) {\n    try {\n      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then;\n        if (newValue instanceof Promise) {\n          self._state = 3;\n          self._value = newValue;\n          finale(self);\n          return;\n        } else if (typeof then === 'function') {\n          doResolve(bind(then, newValue), self);\n          return;\n        }\n      }\n      self._state = 1;\n      self._value = newValue;\n      finale(self);\n    } catch (e) {\n      reject(self, e);\n    }\n  }\n\n  function reject(self, newValue) {\n    self._state = 2;\n    self._value = newValue;\n    finale(self);\n  }\n\n  function finale(self) {\n    if (self._state === 2 && self._deferreds.length === 0) {\n      setTimeout(function() {\n        if (!self._handled) {\n          onUnhandledRejection(self._value);\n        }\n      }, 1);\n    }\n    \n    for (var i = 0, len = self._deferreds.length; i < len; i++) {\n      handle(self, self._deferreds[i]);\n    }\n    self._deferreds = null;\n  }\n\n  function Handler(onFulfilled, onRejected, promise) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.promise = promise;\n  }\n\n  /**\n   * Take a potentially misbehaving resolver function and make sure\n   * onFulfilled and onRejected are only called once.\n   *\n   * Makes no guarantees about asynchrony.\n   */\n  function doResolve(fn, self) {\n    var done = false;\n    try {\n      fn(function (value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      }, function (reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      });\n    } catch (ex) {\n      if (done) return;\n      done = true;\n      reject(self, ex);\n    }\n  }\n\n  Promise.prototype['catch'] = function (onRejected) {\n    return this.then(null, onRejected);\n  };\n\n  Promise.prototype.then = function (onFulfilled, onRejected) {\n    var prom = new Promise(noop);\n    handle(this, new Handler(onFulfilled, onRejected, prom));\n    return prom;\n  };\n\n  Promise.all = function () {\n    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);\n\n    return new Promise(function (resolve, reject) {\n      if (args.length === 0) return resolve([]);\n      var remaining = args.length;\n\n      function res(i, val) {\n        try {\n          if (val && (typeof val === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, reject);\n              return;\n            }\n          }\n          args[i] = val;\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        } catch (ex) {\n          reject(ex);\n        }\n      }\n\n      for (var i = 0; i < args.length; i++) {\n        res(i, args[i]);\n      }\n    });\n  };\n\n  Promise.resolve = function (value) {\n    if (value && typeof value === 'object' && value.constructor === Promise) {\n      return value;\n    }\n\n    return new Promise(function (resolve) {\n      resolve(value);\n    });\n  };\n\n  Promise.reject = function (value) {\n    return new Promise(function (resolve, reject) {\n      reject(value);\n    });\n  };\n\n  Promise.race = function (values) {\n    return new Promise(function (resolve, reject) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        values[i].then(resolve, reject);\n      }\n    });\n  };\n\n  /**\n   * Set the immediate function to execute callbacks\n   * @param fn {function} Function to execute\n   * @private\n   */\n  Promise._setImmediateFn = function _setImmediateFn(fn) {\n    asap = fn;\n  };\n  \n  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n    onUnhandledRejection = fn;\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Promise;\n  } else if (!root.Promise) {\n    root.Promise = Promise;\n  }\n\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/promise-polyfill/promise.js\n ** module id = 2\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 3\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 4\n ** module chunks = 0\n **/","(function (thisVar, undefined) {\n\t'use strict';\n\tvar main = (typeof window === 'object' && window) || (typeof global === 'object' && global) ||\n\t\ttypeof self === 'object' && self || thisVar;\n\n\tvar hasSetImmediate = typeof setImmediate === 'function';\n\tvar hasNextTick = typeof process === 'object' && !!process && typeof process.nextTick === 'function';\n\n\tvar setAsap = (function () {\n\t\tvar callbacks = [], hiddenDiv, scriptEl, timeoutFn;\n\n\t\t// Modern browsers, fastest async\n\t\tif (main.MutationObserver) {\n\t\t\thiddenDiv = document.createElement(\"div\");\n\t\t\t(new MutationObserver(executeCallbacks)).observe(hiddenDiv, { attributes: true });\n\t\t\treturn getAsap(function () {\n\t\t\t\thiddenDiv.setAttribute('yes', 'no');\n\t\t\t});\n\n\t\t// Browsers that support postMessage\n\t\t} else if (!hasSetImmediate && main.postMessage && !main.importScripts && main.addEventListener) {\n\t\t\tvar MESSAGE_PREFIX = \"com.setImmediate\" + Math.random(), hasPostMessage = false;\n\n\t\t\tvar onGlobalMessage = function (event) {\n\t\t\t\tif (event.source === main && event.data === MESSAGE_PREFIX) {\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmain.addEventListener(\"message\", onGlobalMessage, false);\n\n\t\t\treturn getAsap(function () {\n\t\t\t\tmain.postMessage(MESSAGE_PREFIX, \"*\");\n\t\t\t});\n\n\t\t\t// IE browsers without postMessage\n\t\t} else if (!hasSetImmediate && main.document && 'onreadystatechange' in document.createElement('script')) {\n\t\t\treturn getAsap(function () {\n\t\t\t\tscriptEl = document.createElement(\"script\");\n\t\t\t\tscriptEl.onreadystatechange = function () {\n\t\t\t\t\tscriptEl.onreadystatechange = null;\n\t\t\t\t\tscriptEl.parentNode.removeChild(scriptEl);\n\t\t\t\t\tscriptEl = null;\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t};\n\t\t\t\tdocument.body.appendChild(scriptEl);\n\t\t\t});\n\n\t\t// All other browsers and node\n\t\t} else {\n\t\t\ttimeoutFn = (hasSetImmediate && setImmediate) || (hasNextTick && process.nextTick) || setTimeout;\n\t\t\treturn getAsap(function () {\n\t\t\t\ttimeoutFn(function () {\n\t\t\t\t\texecuteCallbacks();\n\t\t\t\t}, 0);\n\t\t\t});\n\t\t}\n\n\t\tfunction getAsap(fn) {\n\t\t\treturn function (callback) {\n\t\t\t\tif (!callbacks.length) {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t\tcallbacks.push(callback);\n\t\t\t}\n\t\t}\n\n\t\tfunction executeCallbacks() {\n\t\t\tvar cbList = callbacks;\n\t\t\tcallbacks = [];\n\t\t\tfor (var i = 0, len = cbList.length; i < len; i++) {\n\t\t\t\ttryError(cbList[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction tryError(fn) {\n\t\t\ttry {\n\t\t\t\tfn();\n\t\t\t} catch(e) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t})();\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = setAsap;\n\t} else if (typeof require !== 'undefined' && require.amd) {\n\t\tdefine(function () {\n\t\t\treturn setAsap;\n\t\t});\n\t} else {\n\t\tmain.setAsap = setAsap;\n\t}\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/setasap/setAsap.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}